

《Designing data intensive applications》
《Clean architecture》
《大型网站技术架构》
《企业应用架构模式》


# 技术目标
- 高可用(避免发生、降低概率、控制影响、快速恢复)
    - 无单点问题：集群部署、主从模式、多地部署
    - 隔离：业务隔离、数据隔离、系统隔离
    - 故障检测和恢复：可灰度、可监控、可回滚
    - 限流降级熔断
- 无限伸缩
- 低成本


# 目标-手段
## 分层: 拆分复杂度，复用
## 解耦: MQ, Observer
## 质心
以参与者为质心，参与者关系为基础，参与者行为作为驱动力。
分析业务场景，参与者Entity、参与者关系Relation（静态）、参与者行为Action（动态）、关系和行为规则


## 分布式CAP原则

## 大容量、高并发
分而治之：分库分表、map-reduce

无锁化处理：分桶（参见AtomicInteger的设计）

异步化批量处理：NIO，任务表+后台任务

空间换时间：多样化存储：Redis, MongoDB, ElasticSearch

缓存、冗余：平衡一致性(Consistency) -- 可用性(Availability)

## 灾备


## 数据库扩容，如何免迁移？

分库分表，rehash数据重新分布是个麻烦事，
但是仔细想想，为什么扩容就非得rehash数据呢？

分库分表无非就是根据数据来看怎么将数据分桶，我们一般用的按id取模mod，
然后取模天然的特性是：有利于数据均匀分布，但是对扩容不友好，

那么不用取模行不行？反过来想，除法对扩容是很友好的，能否两者结合？

---

### 1. 取模mod 
对于取模来说，bocketNo = id mod N ，N代表了固定的桶数。
好处是：纵向增长好，随着数据填进来，每个桶里面的数据能够均匀分布，每个桶里面的水（数据）量相差不大，一齐增长。
坏处是：横向增长难，想要将分桶 bocket -> bocket + X，数据要重新分布。

---

### 2. 除法
bucketNo = id / M，M 代表一个桶放最多放数据，余数作为桶编号。
好处是：横向增长好，随着数据量增长，按需线性扩容，分桶数从bocket->bocket+x很简单。
坏处是：数据分布不太均衡，前面的桶是满的，一个桶是半满状态，后面的桶都是空的（意味着预估不准浪费的资源）。

---
### 3. 除法和mod结合
除法做分库，用mod做分表：

M = 一个库最多放1024万数据
N = 一个库固定8个表，每个表最多128万数据

库 = id / 1024万
表 = id % 8

扩容的时候，预估好数据量，需要几个库就扩几个，按库扩容，简单方便。
如果预估做得好的话，只有一个库的数据不是满载的。


### 一致性hash 
todo







