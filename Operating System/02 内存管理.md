https://draveness.me/system-design-memory-management/


# 内存管理核心目标是什么？
个人理解，操作系统对内存管理的设计都是围绕几个目标来实现的：
1、高效：用尽可能少的内存服务更多的任务；由此产生了虚拟内存的设计，以及内存布局设计。
2、安全：避免、减轻恶意代码的影响；由此产生了kernel/user space.
3、易用：封装复杂性，给用户的api足够强大灵活，但尽可能简单易用；

# 内存管理API
- 申请内存 Allocator
- 释放内存 Collector
- 修改内存值 Mutator

# 内存布局

- Stack 栈区：存储程序执行期间的函数参数和本地变量等，从高->低地址增长；
- Heap 堆区：动态内存分配区域，通过malloc, new, free, delete等函数管理；
- BSS 未初始化变量：存储未被初始化的全局变量和静态变量；
- Data 数据区：存储源码中有预定义值的全局变量和静态变量；
- Text 代码区：存储只读的程序代码，即机器指令；

上述五种不同段虽然存储着不同的数据，但是我们可以将它们分成三种不同的内存分配类型，也就是静态内存、栈内存和堆内存。
- 静态内存(BSS, Data)：编译器确认，固定内存，无运行时，不支持递归；
- 栈内存：支持递归，固定内存，栈指针管理（Extended Base Pointer, Extended Stack Pointer)；
- 堆内存：灵活，按需分配，可变大小，内存泄露，悬挂指针；


# 管理方式
注意：
虽然进程的内存可以划分成很多区域，但是**当我们在谈内存管理时，一般指的都是【堆内存】的管理**。
也就是如何解决内存泄漏和悬挂指针的问题。


## 手动管理
容易产生内存泄露，悬挂指针问题；


# 内存分配
- 线性内存分配(Sequential Allocator)
    - 优势：O(1)快速
    - 劣势：释放内存时产生孔洞，无法充分利用，需要标记压缩(Mark-Compact)或者复制回收(Copy GC)

- 空闲链表分配(Free-list Allocator)
    - 优势：内存利用率高
    - 劣势：O(n)慢，需要维护空闲链表；
    - 四种策略
        - 首次适应(First-Fit)
        - 循环首次适应(Next-Fit)
        - 最优适应(Best-Fit)
        - 隔离适应(Segregated-Fit)

**隔离适应(Segregated-Fit)**
将内存分割为多个链表，一个链表中每块内存大小相同，不同链表粒度不同。
隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。


# 自动管理
- 引用计数器技术：使用对象头MarkWord敦促应用计数器，例如（Objective-C, Netty的ByteBuf）
- 垃圾回收技术：使用对象头MarkWord存储垃圾回收元数据，例如Java和Go（分代年龄、锁等）；


## 垃圾回收
**吞吐量(Throughput)，最大暂停时间(Pause Time)** 是衡量垃圾回收性能的两个主要指标。

垃圾回收技术：
- 标记清除(Mark-Sweep)：空闲链表分配
- 标记压缩(Mark-Compact)：支持线性分配
- 复制垃圾回收(Copy GC)：支持线性分配，内存利用率<50%.
- 分代垃圾回收：不同generation采用上面不同的回收策略；
- 增量并发式回收：分而治之，解决吞吐量问题；
- 三色标记：分而治之，解决标记过程中STW时间太长问题。
想要并发或者增量地标记对象还是需要使用屏障技术。


### 复制垃圾回收
Q：复制涉及移动对象，如何解决指针问题？

A：复制垃圾回收的执行过程可以分为四个阶段：
- 复制阶段 — 从 GC 根节点出发遍历内存中的对象，将发现的存活对象迁移到右侧的内存中；
- 转发阶段 — 在原始对象的对象头或者在原位置设置新对象的转发地址（Forwarding Address），如果其他对象引用了该对象可以从转发地址转到新的地址；
- 修复指针 — 遍历当前对象持有的引用，如果引用指向了左侧堆中的对象，回到第一步迁移发现的新对象；
- 交换阶段 — 当内存中不存在需要迁移的对象之后，交换左右两侧的内存区域；

####分代垃圾回收
Q：跨代应用问题怎么解决？

**卡表(Card Table)存储跨代引用信息**   
**写屏障(Write Barrier)识别跨代引用**    
写屏障是当对象之间的指针发生改变时调用的代码片段，这段代码会判断该指针是不是从老年代对象指向青年代对象的跨代引用。
如果该指针是跨代引用，系统会在卡表中标记老年代对象所在的区域：

### 三色标记
分而治之，解决标记过程中STW时间太长问题。
想要并发或者增量地标记对象还是需要使用屏障技术。

三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：

1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述两个步骤直到对象图中不存在灰色对象；

当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，

#### 三色不变性
想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：

- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径11；

遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。

#### 内存屏障 实现三色不变性
垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种。

因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用【写屏障】保证三色不变性。

几种写屏障技术，分别是 Dijkstra 提出的插入写屏障12和 Yuasa 提出的删除写屏障。

##### Dijkstra插入写屏障
论文：https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html


```go
writePointer(slot, ptr):
    shade(ptr)
    *field = ptr
```

#### Yuasa 删除写屏障
论文：https://www.sciencedirect.com/science/article/pii/016412129090084Y


```go
writePointer(slot, ptr)
    shade(*slot)
    *slot = ptr
```


# 虚拟内存管理

page table页表

page replacement页置换



# 算法
- 申请内存算法
- 释放内存算法


