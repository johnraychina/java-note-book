


## 怎么预防 或者避免死锁？
死锁检测技术

## 怎么调度兼顾公平 和 效率？
多级反馈队列

## 进程通信？
https://www.cnblogs.com/xiaolincoding/p/13402297.html

- 管道 pipline：基于内核缓冲区，匿名管道（父子进程），命名管道（可以在不相关的进程间也能相互通信）
- 消息队列 msg：基于内核中的消息链表
- 共享内存 mmap：拿出一块虚拟地址空间来，映射到相同的物理内存中，避免了上下文切换，但存在并发修改问题。
- 信号量 semaphore ：实现进程间的互斥与同步，配合共享内存可以实现安全数据共享。
- 信号signal：kill -l 查看所有信号
- 套接字socket



- 管道 pipline：基于内核缓冲区，匿名管道（父子进程），命名管道（可以在不相关的进程间也能相互通信）
- 消息队列 msg：基于内核中的消息链表
- 共享内存 mmap：拿出一块虚拟地址空间来，映射到相同的物理内存中，避免了上下文切换，但存在并发修改问题。
- 信号量 semaphore ：实现进程间的互斥与同步，配合共享内存可以实现安全数据共享。
- 信号signal：kill -l 查看所有信号
- 套接字socket

# 调度模型
- 抢占式(preemptive) / 协作式(coperative)
- 单调度器 / 多调度器
- 任务分享 / 工作窃取

# 调度系统目标
先搞清楚目标，再来看如何达到目标。
个人理解：调度系统的设计目标归结成一句话就是：让系统处理任务能力趋近最优状态。

那么我们如何定义“最优”呢？

**公平与效率**
公平与效率是天平的两端，那么如何度量和权衡 公平与效率呢？

- 公平：任务等待时间   
如果调度不够公平，就容易产生“饥饿问题”。
但是“公平”是有权重的，不同任务等待时间，对应的代价并不相同：
比如文件传输任务的公平权重就比较低，而控制系统的用户操作（刹车、转向）公平权重就比较高；
所以就出现了【优先级】和【抢占】的设计。

- 效率：任务执行时间 / (任务执行时间 + 上下文切换时间)
如果苛求公平，势必造成上下文频繁切换，导致低效。

感悟：
- 对于实时性要求很高的系统的调度，最重要的是公平（比如用户界面操作等）；
- 而对于后台系统的调度，更加倾向效率（统计报表、文件传输等）；

所以说，还是要【具体问题具体分析】，回归到场景中，才能做出最好的权衡。

**通用性**
不同特征的任务，对资源的需求不同：   
- 资源要求: IO密集型 / 计算密集型
- RT/Throughput: 响应优先 / 吞吐量优先

感悟：对于通用系统，将特征差异比较大的任务混合部署，能够起到削峰填谷，充分利用资源的作用：
所以很多云厂商就利用了**混合部署技术**，用更少的服务器支持了更多的任务处理：
1. 将  日间实时交易 / 夜间批量作业 调度给同一批服务器来处理;
2. 将  IO密集型任务 / 计算密集型任务 调度给同一批服务器来处理;

这种削峰填谷的朴素思想节省了大量的服务器成本。


**小结**
调度系统的设计者需要考虑的是，设计一个调度模型（数据结构+算法），能够适应不同特征的任务（一定程度的通用性），
同时保证一定的程度公平和效率。

# Linux进程调度/Go语言调度/K8S调度/其他调度

## Linux进程调度
Linux的CPU调度并不是一开始就像今天这样复杂的，在很长一段时间里（v0.01~v2.4)，Linux的进程调度就是由几十行简单函数复杂而，我们先了解一下调度器不同版本的历史：

- 初始调度器 · v0.01 ~ v2.4
由几十行代码实现，功能非常简陋；
同时最多处理 64 个任务；
- 调度器 · v2.4 ~ v2.6
调度时需要遍历全部任务；
当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；
- 调度器 · v2.6.0 ~ v2.6.22
通过引入运行队列和优先数组实现的时间复杂度;
使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性；
引入工作窃取保证多个运行队列中任务的平衡；

- 完全公平调度器 · v2.6.23 ~ 至今
引入红黑树和运行时间保证调度的公平性；
引入调度类实现不同任务类型的不同调度策略；


### 完全公平调度器(Compelete Fair Scheduler)
https://draveness.me/system-design-scheduler/#fn:2

## Go语言调度：GMP模型

## K8S调度


## 其他调度
### CSP模型
### Akka Actor模型
### LMAX Disruptor 模型
https://lmax-exchange.github.io/disruptor/
https://tech.meituan.com/2016/11/18/disruptor.html


# 参考

Wikipedia: Scheduling (computing) ↩︎

Scheduling: Theory, Algorithms, and Systems ↩︎

Scheduling multithreaded computations by work stealing ↩︎

descheduler · GitHub ↩︎

How Linux handles threads and process scheduling ↩︎

schedule · Linux 0.01 ↩︎

O(n) 调度器遍历就绪队列 ↩︎

Understanding the Linux Kernel, Third Edition. ↩︎

Introducing the 2.6 Kernel ↩︎

Wikipedia: Completely Fair Scheduler ↩︎

Wikipedia: Red-black tree ↩︎

Linux Scheduler ↩︎

Communicating sequential processes ↩︎

为什么使用通信来共享内存 ↩︎

Scalable Go Scheduler Design Doc ↩︎

Pre-emption in the scheduler ↩︎

Go Preemptive Scheduler Design Doc ↩︎

runtime: goroutines do not get scheduled for a long time for no obvious reason ↩︎

Proposal: Non-cooperative goroutine preemption ↩︎

Proposal: Conservative inner-frame scanning for non-cooperative goroutine preemption ↩︎

NUMA-aware scheduler for Go ↩︎

Borg, Omega, and Kubernetes ↩︎

谈 Kubernetes 的架构设计与实现原理 ↩︎

Scheduling Framework ↩︎