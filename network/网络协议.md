https://wizardforcel.gitbooks.io/network-basic/content/

https://coolshell.cn/articles/11564.html
https://coolshell.cn/articles/11609.html

# 网络分层
应用层Application Layer：
添加内容：Encoded application data
	DHCP协议for动态IP地址
	DNS协议: 域名 -> host IP
	HTTP协议

传输层Transport Layer：端口到端口通信
添加内容：Destination and source process number(port)
协议：TCP, UDP
	端口port
	套接字Socket(IP + Port)

网络层Network Layer：主机到主机通信
添加内容：Destination and source network addresses
设备：路由器，实现寻址
	IP协议
	子网掩码subnet mask
	ARP地址解析协议(IP -> Mac)

数据链路层Data Link Layer：
添加内容：Destination and source physical addresses
设备：网卡、交换机，通过MAC地址转发数据，逻辑链路控制
	Ethernet  Frame=Head+Data
	Mac地址
	广播Broadcasting

物理层Physical Layer：光电信号0 1 
添加内容：Timing and Synchronization
设备：集线器


##  Protocol Data Unit协议数据单元
https://en.wikipedia.org/wiki/Protocol_data_unit
PDU协议数据单元，是指网络中在对等实体之间传输的信息单元。
- Transport layer: TCP Segment 报文段 , UDP Datagram数据报
- Internet layer: packet包
- Link layer: frame帧




## http协议

### http 2.0
https://developers.google.com/web/fundamentals/performance/http2

One connection per origin: 基于google的SPYDY技术，解决阻塞问题，一个网站只需要开一个连接。
Streams, messages, frames
Binary Framing: 二进制分帧，多个frame乱序发送，接收时再根据frame首部的流标志重新组装。
Header compression: HPACK算法压缩头部，另外，同一个域名下的两个请求，只发送差异数据，减少冗余传输。
Multiplexing: 多路复用，一个域名只需要一个连接。
Server push: 服务端推送，解决轮询问题。
Security: 采用SSL, TSL加密

缺陷：仍然存在对头阻塞问题(head blocking), 初始建立安全连接慢.

### http 3.0


## TCP协议
面向字节流的协议, stream -> 报文段segment
https://wizardforcel.gitbooks.io/network-basic/content/7.html

### TCP三次握手
https://juejin.im/post/6844903889146216456
第一次：客户端发送连接请求报文给服务端，其中SYN=1,seq=x。发送完毕后进入SYN_END状态。
第二次：服务端接收到报文后，发回确认报文，其中ACK=1,ack=x+1，因为需要客户端确认，所以报文中也有SYN=1,seq=y的信息。发送完后进入SYN_RCVD状态。
第三次:客户端接收到报文后,发送确认报文，其中ACK=1,ack=y+1。发送完客户端进入ESTABLISHED状态，服务端接收到报文后，进入ESTABLISHED状态。到此，连接建立完成。

三次握手原因
避免资源被浪费掉。如果在第二步握手时，由于网络延迟导致确认包不能及时到达客户端，那么客户端会认为第一次握手失败，再次发送连接请求，服务端收到后再次发送确认包。在这种情况下，服务端已经创建了两次连接，等待两个客户端发送数据，而实际却只有一个客户端发送数据。

https://coolshell.cn/articles/11564.html
SYN 超时问题：
在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。

SYN Flood攻击
tcp_syncookies
第一个是：tcp_synack_retries 可以用他来减少重试次数；
第二个是：tcp_max_syn_backlog，可以增大SYN连接数；
第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。

**关于ISN的初始化**
Maximum Segment Lifetime(MSL)
RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – Wikipedia语条），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。

**关于 MSL 和 TIME_WAIT**
在TCP断开连接时，从TIME_WAIT到CLOSED有个超时设置，2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）。
为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：
1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，
2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》

### 四次挥手
第一次挥手：客户端发送FIN=1，seq=x的包给服务端，表示自己没有数据要进行传输，单面连接传输要关闭。发送完后，客户端进入FIN_WAIT_1状态。
第二次挥手：服务端收到请求包后，发回ACK=1,ack=x+1的确认包，表示确认断开连接。服务端进入CLOSE_WAIT状态。客户端收到该包后，进入FIN_WAIT_2状态。此时客户端到服务端的数据连接已断开。
第三次挥手：服务端发送FIN=1,seq=y的包给客户端，表示自己没有数据要给客户端了。发送完后进入LAST_ACK状态，等待客户端的确认包。
第四次挥手：客户端收到请求包后，发送ACK=1,ack=y+1的确认包给服务端，并进入TIME_WAIT状态，有可能要重传确认包。服务端收到确认包后，进入CLOSED状态，服务端到客户端的连接已断开。客户端等到一段时间后也会进入CLOSED状态。


### TCP滑动窗口
可靠传输：保证数据送达，如果未到达，能够发现并重传。
控制拥塞：管理数据的发送速率，不至于接收数据过载。


设备A 发送消息给 设备B
每条消息设置一个识别号，可以被独立确认。同一时刻可以发送多条消息。
设备B定期给A发送一条限制参数，制约设备A一次可发送的消息最大量。
片段发送确认，最后一个字节sequence number：提高速度。

**TCP数据流状态**
1. 已发送 已确认
2. 已发送 未确认
3. 未发送 接收方ready
4. 未发送 接收方not ready

**sequence number设定与同步**

发送窗口：已发送未确认+未发送接收方ready
可用窗口：考虑到正在传输的数据量，发送方仍被允许发送的数据量。实际上等于第3类（未发送接收方ready）的大小。


确认处理和窗口缩放：
1、发送可用窗口内字节，可用窗口缩小为空。
2、接收方会发送成功接收后的最长字节数。
3、发送方收到这个最长字节数后，向后滑动对应字节数，可用窗口扩大对应字节数。

### TCP重传机制
TCP片段重传计时器 + 重传队列
简单的方法：每次发送一个片段，就开启一个重传计时器，如果超时未确认，就重传片段。
高效的方法：
	发送片段时，将副本放置于重传队列中，计时器开始。
	收到确认消息则重队列移除该片段。
	如果重传超时，则rest计时
	器再次重传，直到超过限定次数，并判断出现故障终止连接。

Q 要知道重传是基于片段的，而TCP确认消息是基于序列号累计的，怎样判断一个片段被完全确认呢？
A 

Q 如何判断一个片段为丢失片段？

Q 重传计时器，如果时间太短容易发生过量重传，太长容易导致传输效率低下。
A 如何设置呢：自适应动态调整。

### TCP确认机制
- 仅重传超时的片段
- 重传超时+后面的所有片段
- 快速重传机制
TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。
也就是说，如果包没有连续到达，就ack最后那个可能被丢了的包，
如果发送方连续收到3次相同的ack，就重传。
Fast Retransmit的好处是不用等timeout了再重传。

- SACK，需要在握手阶段，双方协商同时支持此机制：
问题的关键在于无法确认非连续片段。
解决方式是对TCP滑动窗口算法进行扩展，添加允许设备分别确认非连续片段的功能。
这一功能称为选择确认（selective acknowledgment, SACK）。

Duplicate-SACK	
Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了
可见，引入了D-SACK，有这么几个好处：

1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。
2）是不是自己的timeout太小了，导致重传。
3）网络上出现了先发的包后到的情况（又称reordering）
4）网络上是不是把我的数据包给复制了。
知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。
Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）

### TCP窗口调整与流量控制
窗口的本质：
代表设备对于特定链接接收缓冲区大小，即窗口大小代表了一次能够对端处理多少数据，之后再传递给应用层处理。

### TCP拥塞控制机制
TCP进行拥塞控制的算法有四种（基于滑动窗口）：慢开始、拥塞避免、快重传、快恢复


## UDP协议

检验和、伪首部

在传输的过程中，如果接收方UDP发现收到的报文中的目的端口不存在，会直接丢弃，然后由网际控制报文协议ICMP给发送方发送“端口不可达”差错报文。

计算校验和时，需要在UDP之前增加12个字节的伪首部。这种首部并不是用户数据报的真正首部。伪首部并不在网络中传输，只是在计算检验和，临时添加在UDP用户数据报前，得到一个临时的用户数据报。


## NAT地址转换协议
network address transformation
将少数公网IP地址共享给大量私有主机。
在本地网络与公网之间安装一个或多个具有NAT功能的路由器。
NAT路由器实现的功能包括将数据报中私网地址转换成公网地址，反向亦然。当有报文通过时，网络地址转换其不仅检查报文信息，还将报文头中的IP地址和端口信息进行修改，以使处于NAT之后的机器共享少数公网IP地址。

## ICMP协议和ARP协议
ICMP = internet control message protocol 网络消息控制协议
通过IP地址寻找MAC地址，得到一张ARP缓存表。

ARP = address resolotion protocal 地址解析协议


## DHCP协议
Dynamic Host Configuration Protocol动态主机配置协议，使用UDP协议工作。
客户端向DHCP服务器发送请求IP地址的真实报文称为DHCPDISCOVER报文。
网络上每一台安装了TCP/IP协议的主机都会接收到这种广播信息，但只有DHCP服务器才会做出响应。



## SSL安全套接层 & TLS安全传输层协议
https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/

目的：提供私密性（防窃听），信息完整性（范篡改），身份证认证（防伪造）。

## 加密与解密

RSA
DH
MD5
SHA-1
SHA-256







