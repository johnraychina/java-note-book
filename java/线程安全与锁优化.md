# What 什么是线程安全？

一个对象可以被多个线程安全地使用。

对象本身封装了必要的正确性保障手段，调用者无需关心多线程访问的问题，更无需采取任何措施来保证多线程的正确调用。


Java Concurrency In Practice:
当多个线程访问同一个对象时，如果不需要考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调工作，调用这个对象的行为就能获得正确的结果，那这个对象就是线程安全的。


## Java语言中的线程安全

- 不可变 Immutable
- 绝对线程安全 
- 相对线程安全, Vector, HashTable等（Java 多数线程安的类都是此类）
- 线程兼容, ArrayList, HashMap等
- 线程对立, Thread的suspend/resume, System.setIn/setOut/runFinalizersOnExit等

# How 如何先线程安全？

##1、互斥同步(Mutual Exclusion & Synchronization) 悲观策略
同步是目的，互斥是手段：Critical Section, Mutex, Semaphore

* Synchronized（非公平锁）
编译之后，变成 monitorenter+monitorexit两个字节码指令，在实例对象或者类对象上加锁(Object Header的MarkWord)

* ReentrantLock
可中断、可实现公平锁，锁可以绑定多个条件

互斥同步存在的问题：线程阻塞和线程唤醒带来的性能问题（内核态-用户态切换）


## 2、非阻塞同步(Non-Blocking Synchronization) 乐观策略
需要操作系统，指令集和硬件层面的支持：
Test and Set
Fetch and Increment
Swap
CAS: Compare and Swap
LL/SC: Load-Linked/Store-Conditional

## 3、无同步方案
无状态函数
无状态设计（http）
线程本地存储

# 锁优化
1、自旋锁与自适应自旋Spinning：
-XX:+UseSpinning
-XX:PreBlockSpin
基于一个假设：自旋代价小于线程阻塞+唤醒代价，自旋太多次也会浪费cpu，这是个需要做balance的地方。

2、锁粗化Lock Coarsening 

3、锁消除Lock Elimination 

4、轻量级锁（相对与使用操作系统Mutex实现的传统锁而言的）:
基于一个假设：绝大部分的锁，在整个同步周期内都是不存在竞争的。
栈LockRecord <--CAS--> MarkWord


5、偏向锁Biased Locking
-XX:+UseBiasedLocking

无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁, 锁只能升级, 不能降级.

todo 分析
AbstractQueuedSynchronizer
LockSupport










